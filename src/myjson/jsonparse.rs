/*! # JSON utils
 * The structs **JSONelm**, **JSONtable**, and **JSONMap** will be used in struct **JSONUtils**
 * Function **calculate_name_from_path** will compute name from path according to name pool
 * Function **calculate_table_seq_list_from_all_table_path** will compute sequence variable for sub-table
 * Function **json_map_loop** will go through whole JSON to get all full paths, including array path
 */
// extern crate log;

use serde_json::Value;
use std::collections::HashMap;
type JsonMap = HashMap<String, serde_json::Value>;
use uuid::Uuid;

/** # struct JSONelm
 * JSON element including JSON path
 */
#[derive(Debug, Clone)]
struct JSONelm{
    clm_name : String,  // column name in table
    json_path : String, // full path in String format
}
/** # struct JSONtable
 * JSON table including columns and according JSON path
   - use array of struct JSONelm
 * Ordered by JSONelm.clm_name
 * Number of ordinary columns
 * Extra structure: is it sub table or not
   - bool variable sub_table
   - If sub_table is true, this table will have two special elements
   - number of sequence variables
   - list of JSONelm for sequence variables
   - JSONelm.clm_name is artificial one, like seq_num, seq_num_2
   - JSONelm.json_path is the parent table path
 */
#[derive(Debug, Clone)]
struct JSONtable{
    tbl_name: String,        // table name
    clm_num : usize,         // number of ordinary columns
    clm_arr : Vec<JSONelm>,  // column element list
    sub_tbl : bool,          // true: seq_num and seq_arr; false: seq_num=0, seq_arr empty
    seq_num : usize,         // if sub_tbl, seq_num > 0, else seq_num = 0
    seq_arr : Vec<JSONelm>,  // sequence element list
}
/** # struct JSONMap
 * list of tables based on array path list
 * Ordered by path descending
 * Last table is root table
 */
#[derive(Debug, Clone)]
struct JSONMap{
    tbl_numbr : usize,          // number of tables
    tbl_array : Vec<JSONtable>, // array path, descending ordered
}
/** # struct JSONUtils
 * JSON data, can be loaded from data file, string in memory using **load_data** method
 * Full path list, generated by **json_map_loop** function from **gen_all_path** method
 * Full array path list for tables, generated by **json_map_loop** function from **gen_all_path** method
 * JSON map, created from full path list and full array path list using **gen_map** method
 * 
 */
#[derive(Debug, Clone)]
pub struct JSONUtils{
    jdata : serde_json::Value,  // raw JSON data
    all_full_path: Vec<String>, // list of full paths from jdata
    all_arr_path : Vec<String>, // list of paths for array, which will be table in database
    map : Option<JSONMap>,      // map from path to column of tables
}

impl JSONUtils{
    /** # load JSON data
     * Read JSON data file, load into self.jdata
     * Use **serde_json::from_reader** method
     */
    pub fn load_data(path: String) -> Result<Self, &'static str>{
        let file = std::fs::File::open(path).unwrap();
        let reader = std::io::BufReader::new(file);
        let v: Value = match serde_json::from_reader(reader){
            Ok(res) => res,
            Err(err) => {
                error!("In JSONUtils::load_data, serde_json::from_reader(): {}", err);
                return Err("main Failed!");
            }
        };
        let all_path = Vec::new();
        let all_arr = Vec::new();
        Ok(JSONUtils{
            jdata: v,
            all_full_path: all_path,
            all_arr_path: all_arr,
            map: None,
        })
    }
    /** # Get jdata length
     * return length of jdata
     * This function is needed since **JSONUtils.jdata** is private
     */
    pub fn get_jdata_len(self) -> usize{
        return self.jdata.to_string().len()
    }
    /** # analyze JSON data jdata, which is array of JSON
     * Call **json_map_loop** to get two lists
     * sort full path list descending
     * sort array path list descending
     * Remove full path for array
     */
    pub fn gen_all_path(self) -> Result<Self, &'static str>{
        let crt_path : String = "".to_owned();
        let mut cum_array: Vec<String> = Vec::new();
        let mut cum_path: Vec<String> = Vec::new();
        let value: Vec<Value> = serde_json::from_value(self.jdata.clone()).unwrap();
        for val in value {
            let v_map : JsonMap = serde_json::from_value(val).unwrap();
            let cp = crt_path.clone();
            match json_map_loop(v_map, cp, &mut cum_array, &mut cum_path){
                Ok(res) => res,
                Err(err) => {
                    error!("Error in json_map_loop(): {}", err);
                    return Err("JSONUtils::get_all_path failed.")
                }
            };
        }
        // store path in reverse way
        cum_array.sort();
        cum_array.reverse();
        cum_path.sort();
        cum_path.reverse();
        // debug!("DEBUG length of cum_path: {}", cum_path.len());
        // remove elements from cum_path if element in cum_array
        cum_path.retain(|elm|!cum_array.contains(&elm));
        // debug!("DEBUG now length of cum_path: {}", cum_path.len());
        Ok(JSONUtils{
            jdata: self.jdata,
            all_full_path: cum_path,
            all_arr_path: cum_array,
            map: None,
        })
    }
    /** # Get all_arr_path length
     * return length of all_arr_path
     */
    pub fn get_all_arr_len(self) -> usize{
        return self.all_arr_path.len()
    }
    /** # Get all_full_path length
     * return length of all_full_path
     */
    pub fn get_all_path_len(self) -> usize{
        return self.all_full_path.len()
    }
    /** # Create map from all_full_path and all_arr_path
     * Get path list for one table
     * Based on path to compute column name
     * Compute sequence variable for sub-tables
     * Call private functions **calculate_name_from_path** and **calculate_table_seq_list_from_all_table_path**
     */
    pub fn gen_map(self) -> Result<Self, &'static str>{
        // all table structure
        let mut vtbl : Vec<JSONtable> = Vec::new();

        // all paths, remove paths belong to created table
        let mut all_path = self.all_full_path.clone();

        // all paths for table
        let all_arr_path = self.all_arr_path.clone();

        // used table name for duplication check
        let mut tablename_pool : Vec<String> = Vec::new();

        // loop for each sub table
        // rest will be into root table
        for i in 0..self.all_arr_path.len(){
            // compute table name
            let tblpath = all_arr_path[i].clone();
            let tbl = calculate_name_from_path(tblpath.clone(), tablename_pool.clone());
            tablename_pool.push(tbl.clone());

            // compute all path belong to this table
            let tblpathlist : Vec<String> = all_path.clone()
                                        .into_iter()
                                        .filter(|x| x.contains(&tblpath))
                                        .collect();
            // remove paths belong to this table from all_path
            all_path.retain(|elm|!tblpathlist.contains(&elm));
            
            // used column name of this table for duplication check
            let mut columnname_pool : Vec<String> = Vec::new();

            // collection of columns in this table
            let mut columns : Vec<JSONelm> = Vec::new();

            // loop for each column of this table
            for j in 0..tblpathlist.len() {
                // compute column name of this table
                let clmpath = tblpathlist[j].clone();
                let clm = calculate_name_from_path(clmpath.clone(), columnname_pool.clone());
                columnname_pool.push(clm.clone());
                // push to collection for this table
                columns.push(JSONelm{
                    clm_name : clm,
                    json_path : clmpath,
                })
            }
            // Since all these tables are sub-table, need to compute sequence variable
            let all_arr_path = self.all_arr_path.clone();
            let seqs : Vec<JSONelm> = calculate_table_seq_list_from_all_table_path(tblpath, all_arr_path);
            if seqs.len() > 0 {
                vtbl.push(JSONtable{
                    tbl_name: tbl,
                    clm_num : columns.len(),
                    clm_arr : columns,
                    sub_tbl : true,
                    seq_num : seqs.len(),
                    seq_arr : seqs,
                });
            } else { // this code block may not be used at all
                vtbl.push(JSONtable{
                    tbl_name: tbl,
                    clm_num : columns.len(),
                    clm_arr : columns,
                    sub_tbl : false,
                    seq_num : 0,
                    seq_arr : Vec::new(),
                });
            }
        }
        // rest of path will be in root table, similar to above
        // Do not need sequence variable since it is root table
        let tbl = "root".to_owned();
        let mut columnname_pool : Vec<String> = Vec::new();
        let mut columns : Vec<JSONelm> = Vec::new();
        let tblpathlist = all_path;
        for j in 0..tblpathlist.len() {
            let clmpath = tblpathlist[j].clone();
            let clm = calculate_name_from_path(clmpath.clone(), columnname_pool.clone());
            columnname_pool.push(clm.clone());
            // debug!("\tThe {}-th column {} from {}", j + 1, clm, clmpath);
            columns.push(JSONelm{
                clm_name : clm,
                json_path : clmpath,
            })
        }
        vtbl.push(JSONtable{
            tbl_name: tbl,
            clm_num : columns.len(),
            clm_arr : columns,
            sub_tbl : false,
            seq_num : 0,
            seq_arr : Vec::new(),
        });
        // return back
        Ok(JSONUtils{
            jdata: self.jdata,
            all_full_path: self.all_full_path,
            all_arr_path: self.all_arr_path,
            map: Some(JSONMap{
                tbl_numbr : vtbl.len(),
                tbl_array : vtbl,
            }),
        })
    }
}

/** # compute name from path according to namepool
 * String of path have separator '/'
 * The last field will be the name
 * If name already exists in name pool, create new one by appending uuid (random number)
 */
#[allow(dead_code)]
fn calculate_name_from_path(path: String,
                            namepool: Vec<String>
                           )
     -> String
{
    let v: Vec<&str> = path.split('/').collect();
    let mut name = v.last().unwrap().to_lowercase();
    while namepool.contains(&name){
        name = format!("{}_{}",
            v.last().unwrap().to_lowercase(),
            Uuid::new_v4().to_string(),
        );
    }
    return name;
}

/** # compute table sequence list from table path according to all table pathes
 * If this table path contains one of all table pathes, this table is parent table
 * Need sequence number upon this parent table
 */
#[allow(dead_code)]
fn calculate_table_seq_list_from_all_table_path(tablepath: String,
                                                alltablelist: Vec<String>,
    ) -> Vec<JSONelm> {
    let mut vje : Vec<JSONelm> = Vec::new();
    for i in 0..alltablelist.len() {
        if tablepath.contains(&(alltablelist[i])) {
            let taglist : Vec<&str> = alltablelist[i].split('/').collect();
            let tag = taglist.last().unwrap();
            vje.push(JSONelm{
                clm_name : format!("seq_{}", tag),
                json_path : alltablelist[i].clone(),
            })
        }
    }
    vje.reverse();
    return vje;
}

/** # get JSON paths
 * Given JSON map and current path, for each (key, value) pair
 * Add current path and key as the full path
 * Append the full path to cumulative path list if the full path is new in the cumulative path list
 * If value is object, call this function itself for the next level
 * When value is array
 * Append the full path to cumulative array list if the full path is new in the cumulative array list
 * Then loop the array
 * If element of array is object, call this function itself for the next level
 */
#[allow(dead_code)]
pub fn json_map_loop(jm: JsonMap
    , crt_path: String
    , cum_array: &mut Vec<String>
    , cum_path: &mut Vec<String>
    ) -> Result<String, &'static str>{
        for (key, value) in jm.iter() {
            let thispath = format!("{}/{}", crt_path, key);
            if ! cum_path.contains(&thispath) {
                let path = thispath.clone();
                cum_path.push(path);
            }
            if value.is_array(){
                if ! cum_array.contains(&thispath) {
                    let path = thispath.clone();
                    cum_array.push(path);
                }
                // println!("The key '{}' has array '{}'.", key, value);
                let v: Vec<Value> = serde_json::from_value(value.clone()).unwrap();
                for val in v {
                    if val.is_array() {
                        error!("Value is array!!! '{}'", thispath);
                        return Err("Data format is wrong, should be object.");
                    }
                    else if val.is_object() {
                        // println!("Value is object!!! '{}'", val);
                        let v_map : JsonMap = serde_json::from_value(val).unwrap();
                        let crt_path = thispath.clone();
                        json_map_loop(v_map, crt_path, cum_array, cum_path).unwrap();
                    }
                    else {
                        error!("Value is '{}' at '{}'", val, thispath);
                        return Err("Data format is wrong, should be object.");
                    }
                }
            }
            else if value.is_object(){
                // println!("The key '{}' has object '{}'.", key, value);
                let v_map : JsonMap = serde_json::from_value(value.clone()).unwrap();
                let crt_path = thispath.clone();
                json_map_loop(v_map, crt_path, cum_array, cum_path).unwrap();
            }
            // else {
            //     println!("The key '{}' has value '{}'.", key, value);
            // }
        };
        return Ok("OK".to_owned())
    }
